package ncku.topology.engine;

import java.io.IOException;
import java.util.PriorityQueue;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Dijkstra {
  public ArrayList<Vertex> vertices = new ArrayList<Vertex>();
  ArrayList<ArrayList<ArrayList<Integer>>> paths = new ArrayList<>();
  ArrayList<ArrayList<Integer>> pathsSM = new ArrayList<>();

  private float diameter = 0;
  private float average_distance = 0;

  public void computePaths(int src) {
    computePaths(getVertices().get(src));
  }

  public void computePaths(Vertex source) {
    paths = new ArrayList<>();
    int source_id = source.id;
    source.setMinDistance(0.f);
    PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();
    vertexQueue.add(source);

    while (!vertexQueue.isEmpty()) {
      Vertex u = vertexQueue.poll();
      // System.out.println("\n--------\n");
      // Visit each edge exiting u
      for (Edge e : u.adjacencies) {
        Vertex v = e.target;
        // System.out.println("from " + source_id + " via " + u.id + " target " + v.id);

        float distance = e.distance;
        // System.out.println("edge distance = " + distance);

        float distanceThroughU = u.getMinDistance() + distance;
        // System.out.println("distance through " + u.id + " = " + distanceThroughU);
        if (distanceThroughU < v.getMinDistance()) {
          // System.out.println("shorter than original minimum distance " + v.minDistance
          // + " of " + v.id);
          vertexQueue.remove(v);
          // System.out.println("remove " + v.id + " from queue");
          v.setMinDistance(distanceThroughU);
          // System.out.println("set minimum distance of " + v.id + " to " +
          // v.minDistance);
          v.previous = u;
          v.upstream.put(u, distanceThroughU);
          /**
           * Alvyn:
           *
           * v.upstream has multiple entries because I wanted multiple shortest paths to
           * be recorded instead of only one
           * path.
           */
          for (Map.Entry mapEntry : v.upstream.entrySet()) {
            float d1 = (float) mapEntry.getValue();
            if (d1 > distanceThroughU) {
              // System.out.println("===remove " + ((Vertex) mapEntry.getKey()).id + " it has
              // longer distance " + d1);
              v.upstream.remove(mapEntry);
            }
          }
          // System.out.println("set previous of " + v.id + " to " + u.id);
          vertexQueue.add(v);
          // System.out.println("Add " + v.id + " to queue");
        } else if (distanceThroughU == v.getMinDistance()) {
          // System.out.println("equal to original minimum distance " + v.minDistance + "
          // of " + v.id + "\nAdd to the upstream list!");
          v.upstream.put(u, distanceThroughU);
          String keys = "";
          for (Map.Entry mapEntry : v.upstream.entrySet()) {
            keys += ((Vertex) mapEntry.getKey()).id + " ";
          }
          // System.out.println("---Upstream of " + v.id + " now: " + keys);
        } else {
          // System.out.println("longer than original minimum distance " + v.minDistance +
          // " of " + v.id + "\nNext!");
        }
      }
    }
    System.gc();
    // System.out.println("Finish");
  }

  boolean checkIfZeroIsUpstream(ArrayList<Vertex> upNodes) {
    if (upNodes.size() == 1 && upNodes.get(0).id == 0) {
      return true;
    } else {
      return false;
    }
  }

  public ArrayList<Vertex> getNextHopsFromSource(Vertex target) throws IOException {
    boolean finished = false;
    Set<Vertex> upstreamNodes = target.upstream.keySet();
    ArrayList<Vertex> upNodes = new ArrayList<>();
    for (Vertex v1 : upstreamNodes) {
      upNodes.add(v1);
    }

    if (checkIfZeroIsUpstream(upNodes)) {
      /**
       * the upstream node is simply 0 itself.
       */
      upNodes.clear();
      upNodes.add(target);
    } else {
      while (!finished) {
        /**
         * get all the upstream of this layer to a new array
         */
        ArrayList<Vertex> upNodes1 = new ArrayList<>();
        for (int i = 0; i < upNodes.size(); ++i) {
          Set<Vertex> upstreamNodes1 = upNodes.get(i).upstream.keySet();
          for (Vertex v2 : upstreamNodes1) {
            if (!upNodes1.contains(v2)) {
              upNodes1.add(v2);
            }
          }
        }

        if (checkIfZeroIsUpstream(upNodes1)) {
          break;
        }
        upNodes.clear();
        upNodes.addAll(upNodes1);
      }
    }
    return upNodes;
  }

  public void setNVertices(int n) {
    this.getVertices().clear();
    for (int i = 0; i < n; ++i) {
      Vertex v = new Vertex(i);
      this.getVertices().add(v);
    }
  }

  public void makeGraph(boolean isMutual, TreeMap<String, Float> linkMap, int totalN) {
    setNVertices(totalN);
    for (Map.Entry mapEntry : linkMap.entrySet()) {
      String str = (String) mapEntry.getKey();
      String[] arst = str.split(",");
      int i = Integer.valueOf(arst[0]);
      int j = Integer.valueOf(arst[1]);
      Vertex st = getVertices().get(i);
      Vertex en = getVertices().get(j);
      st.adjacencies.add(new Edge(en, 1.0f));
      if (isMutual) {
        en.adjacencies.add(new Edge(st, 1.0f));
      }
    }
  }

  public void makeGraph(boolean isMutual, ArrayList<Integer> start, ArrayList<Integer> end, int totalN) {
    setNVertices(totalN);
    if (start.size() != end.size()) {
      System.err.println("Size unmatch!!");
      System.exit(1);
    }
    int len = start.size();

    for (int i = 0; i < len; ++i) {
      Vertex st = getVertices().get(start.get(i));
      Vertex en = getVertices().get(end.get(i));
      st.adjacencies.add(new Edge(en, 1.0f));
      if (isMutual) {
        en.adjacencies.add(new Edge(st, 1.0f));
      }
    }
  }

  public void makeGraphWithDistance(boolean isMutual, ArrayList<Integer> start, ArrayList<Integer> end,
      ArrayList<Float> distance, int totalN) {

    setNVertices(totalN);

    if (start.size() != end.size()) {
      System.err.println("Size unmatch!!");
      System.exit(1);
    }
    int len = start.size();

    for (int i = 0; i < len; ++i) {
      Vertex st = getVertices().get(start.get(i));
      Vertex en = getVertices().get(end.get(i));
      float dist = distance.get(i);
      st.adjacencies.add(new Edge(en, dist));
      if (isMutual) {
        en.adjacencies.add(new Edge(st, dist));
      }
    }
  }

  // private static void outputPaths(ArrayList<ArrayList<ArrayList<Integer>>>
  // paths) {
  // System.out.println("Shortest paths to node 0");
  // for (int i = 0; i < paths.size(); ++i) {
  // ArrayList<ArrayList<Integer>> curVert = paths.get(i);
  // System.out.println(i + "\n");
  // for (int j = 0; j < curVert.size(); ++j) {
  // ArrayList<Integer> curPath = curVert.get(j);
  // for (int k = 0; k < curPath.size(); ++k) {
  // System.out.println(curPath.get(k) + "\t");
  // }
  // System.out.println("\n");
  // }
  // }
  // }
  void calcDiameter() {
    /**
     * This loop is actually time consuming as diameter should be able to calculate
     * in advance.
     */
    for (Vertex v : getVertices()) {
      float d = v.getMinDistance();
      if (d > getDiameter()) {
        diameter = d;
      }
    }
  }

  void calcAverageDistance() {
    /**
     * This loop is actually time consuming as diameter should be able to calculate
     * in advance.
     */
    for (Vertex v : getVertices()) {
      float d = v.getMinDistance();
      average_distance += d;
    }
    average_distance /= (float) (getVertices().size() - 1);
  }

  /**
   * From vertex zero there are paths to each of the vertices.
   *
   * @return
   * @throws IOException
   */
  public ArrayList<ArrayList<ArrayList<Integer>>> calcU0Paths() throws IOException {
    paths = new ArrayList<>();
    calcDiameter();
    calcAverageDistance();
    for (Vertex v : getVertices()) {
      ArrayList<Integer> indices = new ArrayList<>();
      loopIntoVertex(v, indices, 0);
    }
    return paths;
  }

  // /**
  // * From vertex zero there are paths to each of the vertices.
  // *
  // * @return
  // * @throws IOException
  // */
  // public ArrayList<ArrayList<Integer>> calcU0PathsSaveMem() throws IOException
  // {
  // pathsSM = new ArrayList<>();
  // calcDiameter();
  // for (Vertex v : getVertices()) {
  // ArrayList<Integer> indices = new ArrayList<>();
  // loopIntoVertexSaveMem(v, indices, 0);
  // }
  // return pathsSM;
  // }
  /**
   * This function should
   *
   * @param v
   * @return
   */
  void loopIntoVertex(Vertex v,
      ArrayList<Integer> indices, int level) {
    Set entries = v.upstream.entrySet();
    Iterator iterator = entries.iterator();
    if (!iterator.hasNext()) { // this is the zero vertex itself
      indices = new ArrayList<>();
      indices.add(0);
      curVert = new ArrayList<>();
      curVert.add(indices);
      paths.add(curVert);
      curVert = null;
      return;
    } else { // this tree has at least one branch
      if (level == 0) {
        indices.add(v.id);
        curVert = new ArrayList<>();
      }
      // System.out.println("Upstream count = " + v.upstream.size());
      ArrayList<Integer> levelIndices = cloneList(indices);
      while (iterator.hasNext()) { // stepping in this branch
        indices = cloneList(levelIndices);
        // System.out.println("Level = " + level + ", v = " + v.id);

        Map.Entry mapping = (Map.Entry) iterator.next();
        Vertex u = (Vertex) mapping.getKey();
        int uid = u.id;
        indices.add(uid);
        if (u.getMinDistance() == 0.) { // reached a leave of the tree
          curVert.add(indices);
        } else { // still need to climb up
          loopIntoVertex(u, indices, level + 1);
        }
      }
    }
    if (level == 0) {
      paths.add(curVert);
    }
    return;
  }

  // /**
  // * This function should
  // *
  // * @param v
  // * @return
  // */
  // void loopIntoVertexSaveMem(Vertex v,
  // ArrayList<Integer> indices, int level) {
  // Set entries = v.upstream.entrySet();
  // Iterator iterator = entries.iterator();
  // if (!iterator.hasNext()) { // this is the zero vertex itself
  // indices = new ArrayList<>();
  // indices.add(0);
  // curVert = new ArrayList<>();
  // curVert.add(indices);
  // //paths.add(curVert);
  // curVert = null;
  // return;
  // } else { // this tree has at least one branch
  // if (level == 0) {
  // indices.add(v.id);
  // curVert = new ArrayList<>();
  // }
  // //System.out.println("Upstream count = " + v.upstream.size());
  // ArrayList<Integer> levelIndices = cloneList(indices);
  // while (iterator.hasNext()) { // stepping in this branch
  // indices = cloneList(levelIndices);
  // //System.out.println("Level = " + level + ", v = " + v.id);
  //
  // Map.Entry mapping = (Map.Entry) iterator.next();
  // Vertex u = (Vertex) mapping.getKey();
  // int uid = u.id;
  // indices.add(uid);
  // if (u.getMinDistance() == 0.) { // reached a leave of the tree
  // curVert.add(indices);
  // } else { // still need to climb up
  // loopIntoVertexSaveMem(u, indices, level + 1);
  // }
  // }
  // }
  // if (level == 0) {
  // //paths.add(curVert);
  // }
  // return;
  // }
  public ArrayList<ArrayList<ArrayList<Integer>>> calcU1Paths(ArrayList<ArrayList<ArrayList<Integer>>> u0paths)
      throws IOException {
    ArrayList<ArrayList<ArrayList<Integer>>> paths = new ArrayList<>(u0paths.size());
    for (int i = 0; i < u0paths.size(); ++i) {
      Vertex v = vertices.get(i); // Check each member in the topology
      float d = Float.MAX_VALUE;
      for (int j = 0; j < v.adjacencies.size(); ++j) { // for their adjacencies
        Edge e = v.adjacencies.get(j);
        Vertex target = e.target; // as targets
        if (!v.upstream.containsKey(target)) { // for those adjacency targets not as upstream (not shortest path to
                                               // vertex zero) for the member
          float targetShortestD = target.getMinDistance(); // check their distance to zero
          if (targetShortestD + e.distance < d) { // find the shortest one (this value would be used as sub-shortest
                                                  // path distance)
            d = targetShortestD + e.distance;
          }
        }
      }
      ArrayList<ArrayList<Integer>> pathlist = new ArrayList<>(); // build a path list for sub-shortest paths for each
                                                                  // of the members
      for (int j = 0; j < v.adjacencies.size(); ++j) { // OK now loop through the list again.
        Edge e = v.adjacencies.get(j);
        Vertex target = e.target;
        // get the matching alternative paths to the vertex
        if (!v.upstream.containsKey(target) && target.getMinDistance() + e.distance == d) { // this time get exactly
                                                                                            // those targets with
                                                                                            // sub-shortest distance.
          for (int k = 0; k < u0paths.get(target.id).size(); ++k) { // do the sub-shortest list fot the ith member.
            if (!u0paths.get(target.id).get(k).contains(v.id)) {
              ArrayList<Integer> path = new ArrayList<>();
              path.add(v.id);
              for (int vid : u0paths.get(target.id).get(k)) {
                path.add(vid);
              }
              pathlist.add(path);
            }
          }
        }
      }
      paths.add(pathlist);
    }
    return paths;
  }

  public ArrayList<ArrayList<Integer>> calcSubShortestTargets(ArrayList<ArrayList<ArrayList<Integer>>> u0paths)
      throws IOException {
    ArrayList<ArrayList<Integer>> targets = new ArrayList<>(u0paths.size());
    for (int i = 0; i < u0paths.size(); ++i) {
      Vertex v = vertices.get(i); // Check each member in the topology
      float d = Float.MAX_VALUE;
      for (int j = 0; j < v.adjacencies.size(); ++j) { // for their adjacencies
        Edge e = v.adjacencies.get(j);
        Vertex target = e.target; // as targets
        if (!v.upstream.containsKey(target)) { // for those adjacency targets not as upstream (not shortest path to
                                               // vertex zero) for the member
          float targetShortestD = target.getMinDistance(); // check their distance to zero
          if (targetShortestD + e.distance < d) { // find the shortest one (this value would be used as sub-shortest
                                                  // path distance)
            d = targetShortestD + e.distance;
          }
        }
      }
      ArrayList<Integer> targetlist = new ArrayList<>(); // build a path list for sub-shortest paths for each of the
                                                         // members
      for (int j = 0; j < v.adjacencies.size(); ++j) { // OK now loop through the list again.
        Edge e = v.adjacencies.get(j);
        Vertex target = e.target;
        // get the matching alternative paths to the vertex
        if (!v.upstream.containsKey(target) && target.getMinDistance() + e.distance == d) { // this time get exactly
                                                                                            // those targets with
                                                                                            // sub-shortest distance.
          for (int k = 0; k < u0paths.get(target.id).size(); ++k) { // do the sub-shortest list fot the ith member.
            ArrayList<Integer> path = u0paths.get(target.id).get(k);
            int alt = path.get(0);
            if (!targetlist.contains(alt)) {
              targetlist.add(alt);
            }
          }
        }
      }
      targets.add(targetlist);
    }
    return targets;
  }

  public ArrayList<ArrayList<Integer>> calcSubShortestTargetsSM(ArrayList<ArrayList<Integer>> u0pathsSM)
      throws IOException {
    ArrayList<ArrayList<Integer>> targets = new ArrayList<>(u0pathsSM.size());
    for (int i = 0; i < u0pathsSM.size(); ++i) {
      Vertex v = vertices.get(i); // Check each member in the topology
      float d = Float.MAX_VALUE;
      for (int j = 0; j < v.adjacencies.size(); ++j) { // for their adjacencies
        Edge e = v.adjacencies.get(j);
        Vertex target = e.target; // as targets
        if (!v.upstream.containsKey(target)) { // for those adjacency targets not as upstream (not shortest path to
                                               // vertex zero) for the member
          float targetShortestD = target.getMinDistance(); // check their distance to zero
          if (targetShortestD + e.distance < d) { // find the shortest one (this value would be used as sub-shortest
                                                  // path distance)
            d = targetShortestD + e.distance;
          }
        }
      }
      ArrayList<Integer> targetlist = new ArrayList<>(); // build a path list for sub-shortest paths for each of the
                                                         // members
      for (int j = 0; j < v.adjacencies.size(); ++j) { // OK now loop through the list again.
        Edge e = v.adjacencies.get(j);
        Vertex target = e.target;
        // get the matching alternative paths to the vertex
        if (!v.upstream.containsKey(target) && target.getMinDistance() + e.distance == d) { // this time get exactly
                                                                                            // those targets with
                                                                                            // sub-shortest distance.
          for (int k = 0; k < u0pathsSM.get(target.id).size(); ++k) { // do the sub-shortest list fot the ith member.
            // ArrayList<Integer> path = u0pathsSM.get(target.id).get(k);
            // int alt = path.get(0);
            // if (!targetlist.contains(alt)) {
            // targetlist.add(alt);
            // }
          }
        }
      }
      targets.add(targetlist);
    }
    return targets;
  }

  public static ArrayList<Integer> cloneList(ArrayList<Integer> list) {
    ArrayList<Integer> clone = new ArrayList<Integer>(list.size());
    for (Integer item : list) {
      clone.add(item.intValue());
    }
    return clone;
  }

  ArrayList<ArrayList<Integer>> curVert;

  public float getA() {
    float total = 0.0f;
    float nVer = 0f;
    for (Vertex v : getVertices()) {
      total += v.getMinDistance();
      ++nVer;
    }
    return total / (float) nVer;
  }

  // public boolean alterEdgeWeight(int a, int b, float distance) {
  // ArrayList<Edge> adja = vertices.get(a).adjacencies;
  // ArrayList<Edge> adjb = vertices.get(b).adjacencies;
  // boolean A_has_B = false;
  // boolean B_has_A = false;
  // Edge atob = null;
  // Edge btoa = null;
  // for (int i = 0; i < adja.size(); ++i) {
  // if (adja.get(i).target.id == b) {
  // A_has_B = true;
  // atob = adja.get(i);
  // break;
  // }
  // }
  // for (int i = 0; i < adjb.size(); ++i) {
  // if (adjb.get(i).target.id == a) {
  // B_has_A = true;
  // btoa = adjb.get(i);
  // break;
  // }
  // }
  // if (A_has_B && B_has_A) {
  // atob.distance = distance;
  // btoa.distance = distance;
  // }
  // return true;
  // }
  /**
   * @return the vertices
   */
  public ArrayList<Vertex> getVertices() {
    return vertices;
  }

  /**
   * @param vertices the vertices to set
   */
  public void setVertices(ArrayList<Vertex> vertices) {
    this.vertices = vertices;
  }

  // public static void main(String[] args) throws IOException {
  // //main0();
  // main1();
  // }
  //
  // static void main2() throws IOException {
  // Vertex v0 = new Vertex(0);
  // Vertex v1 = new Vertex(1);
  // Vertex v2 = new Vertex(2);
  // Vertex v3 = new Vertex(3);
  //
  // v0.adjacencies.add(new Edge(v1, 1));
  // v0.adjacencies.add(new Edge(v2, 1));
  // v1.adjacencies.add(new Edge(v0, 1));
  // v1.adjacencies.add(new Edge(v3, 1));
  // v2.adjacencies.add(new Edge(v0, 1));
  // v2.adjacencies.add(new Edge(v3, 1));
  // v3.adjacencies.add(new Edge(v1, 1));
  // v3.adjacencies.add(new Edge(v2, 1));
  //
  // Dijkstra di = new Dijkstra();
  // di.getVertices().add(v0);
  // di.getVertices().add(v1);
  // di.getVertices().add(v2);
  // di.getVertices().add(v3);
  //
  // di.computePaths(v0);
  // outputPaths(di.calcU0Paths());
  //
  // }
  //
  // static void main1() throws IOException {
  // Vertex v0 = new Vertex(0);
  // Vertex v1 = new Vertex(1);
  // Vertex v2 = new Vertex(2);
  // Vertex v3 = new Vertex(3);
  // Vertex v4 = new Vertex(4);
  // Vertex v5 = new Vertex(5);
  // Vertex v6 = new Vertex(6);
  // Vertex v7 = new Vertex(7);
  // v0.adjacencies.add(new Edge(v1, 1));
  // v0.adjacencies.add(new Edge(v3, 1));
  // v0.adjacencies.add(new Edge(v5, 1));
  // v0.adjacencies.add(new Edge(v7, 1));
  // v1.adjacencies.add(new Edge(v2, 1));
  // v1.adjacencies.add(new Edge(v4, 1));
  // v1.adjacencies.add(new Edge(v6, 1));
  // v2.adjacencies.add(new Edge(v3, 1));
  // v2.adjacencies.add(new Edge(v5, 1));
  // v2.adjacencies.add(new Edge(v7, 1));
  // v3.adjacencies.add(new Edge(v4, 1));
  // v3.adjacencies.add(new Edge(v6, 1));
  // v4.adjacencies.add(new Edge(v5, 1));
  // v4.adjacencies.add(new Edge(v7, 1));
  // v5.adjacencies.add(new Edge(v6, 1));
  // v6.adjacencies.add(new Edge(v7, 1));
  //
  // Dijkstra di = new Dijkstra();
  // di.getVertices().add(v0);
  // di.getVertices().add(v1);
  // di.getVertices().add(v2);
  // di.getVertices().add(v3);
  // di.getVertices().add(v4);
  // di.getVertices().add(v5);
  // di.getVertices().add(v6);
  // di.getVertices().add(v7);
  //
  // di.computePaths(v0);
  // outputPaths(di.calcU0Paths());
  //
  // }
  //
  // static void main0() throws IOException {
  // Vertex v0 = new Vertex(0);
  // Vertex v1 = new Vertex(1);
  // Vertex v2 = new Vertex(2);
  // Vertex v3 = new Vertex(3);
  // Vertex v4 = new Vertex(4);
  // Vertex v5 = new Vertex(5);
  // Vertex v6 = new Vertex(6);
  // v0.adjacencies.add(new Edge(v1, 79.83f));
  // v0.adjacencies.add(new Edge(v5, 81.15f));
  // v1.adjacencies.add(new Edge(v0, 79.75f));
  // v1.adjacencies.add(new Edge(v2, 39.42f));
  // v1.adjacencies.add(new Edge(v3, 103.0f));
  // v2.adjacencies.add(new Edge(v1, 38.65f));
  // v3.adjacencies.add(new Edge(v1, 102.53f));
  // v3.adjacencies.add(new Edge(v5, 61.44f));
  // v3.adjacencies.add(new Edge(v6, 96.79f));
  // v4.adjacencies.add(new Edge(v5, 133.04f));
  // v5.adjacencies.add(new Edge(v0, 81.77f));
  // v5.adjacencies.add(new Edge(v3, 62.05f));
  // v5.adjacencies.add(new Edge(v4, 134.47f));
  // v5.adjacencies.add(new Edge(v6, 91.63f));
  // v6.adjacencies.add(new Edge(v3, 97.24f));
  // v6.adjacencies.add(new Edge(v5, 87.94f));
  //
  // Dijkstra di = new Dijkstra();
  // di.getVertices().add(v0);
  // di.getVertices().add(v1);
  // di.getVertices().add(v2);
  // di.getVertices().add(v3);
  // di.getVertices().add(v4);
  // di.getVertices().add(v5);
  // di.getVertices().add(v6);
  //
  // di.computePaths(v0);
  // outputPaths(di.calcU0Paths());
  // }
  /**
   * @return the average_distance
   */
  public float getAverageD() {
    return average_distance;
  }

  /**
   * @return the diameter
   */
  public float getDiameter() {
    return diameter;
  }
}
package ncku.topology.model;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import ncku.topology.engine.Dijkstra;
import ncku.topology.engine.Vertex;
import ncku.topology.web.StandalonePageWriter;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class PowerGridMetrics {
  Logger logger = LoggerFactory.getLogger(this.getClass());

  @Autowired
  StandalonePageWriter standalonePageWriter;

  public String anynet(ArrayList<Integer> src,
                              ArrayList<Integer> dst,
                              int totalN,
                              String metrics,
                              Float alpha,
                              Float beta,
                              String alphaArrStr,
                              Float betaArr) throws IOException {
    // 起終節點數目檢查
    if (src.size() != dst.size()) {
      System.out.println("Source and destination size not match!");
      return "Source and destination size not match!";
    }

    /* Complex Network Metrics */
    // Basic Metrics
    PowerGridMetrics powerGridMetrics = new PowerGridMetrics();
    // distance = powerGridMetrics.Distance(src, dst, totalN);
    // avgDistance = powerGridMetrics.AverageDist(src, dst, totalN);

    String results = "<p>=== Any Network ===</p>"
            + "<p> src: " + src + "</p>"
            + "<p> dst: " + dst + "</p>"
            + "<p> Total Nodes: " + totalN + "</p>"
            + "<p> Total K: " + src.size() / 2 + "</p>";
    // + "<p> Distance: " + distance + "</p>"
    // + "<p> Average distance: " + avgDistance + "</p>";

    System.out.println(metrics);
    // Optional Metrics
    switch (metrics) {
      case "Basic":
        return basic(src, dst, totalN, results, metrics);
      case "EfficiencyAndVulnerability":
        return vulnerability(src, dst, totalN, results, metrics);
      case "DegreeCentrality":
        return degreeCentrality(src, totalN, results, metrics);
      case "BetweennessCentrality":
        return betweennessCentrality(src, dst, totalN, results, metrics);
      case "CascadingFailure":
        return cascadingFailure(src, dst, totalN, alpha, beta, results, metrics);
      case "InfinitePoints":
        return infinitePoints(src, dst, totalN, results, metrics);
      case "MultipleCascadingFailure":
        ArrayList<Float> alphaArr = new ArrayList<>();

        for (String a : alphaArrStr.split(",")) {
          alphaArr.add(Float.valueOf(a));
        }

        return multipleCascadingFailure(src, dst, totalN, alphaArr, betaArr, results, metrics);
    }

    // powerGridMetrics.writeOutput(results, true);
    return results;
  }

  public double AverageDist(ArrayList<Integer> start, ArrayList<Integer> end, int totalN) {
    double sumdist = 0;
    for (int source = 0; source < totalN; source++) {
      Dijkstra diTool = new Dijkstra();
      diTool.makeGraph(false, start, end, totalN);

      diTool.computePaths(source);
      ArrayList<Vertex> vertices = diTool.getVertices();

      for (int destination = 0; destination < totalN; destination++) {
        if (source != destination) {
          double mindist = vertices.get(destination).getMinDistance();

          // System.out.println(source + " to " + destination + " : " + mindist);
          sumdist += mindist; // Sumation of efficiency
        }
      }
    }

    double averagedist = sumdist / (totalN * (totalN - 1));

    return averagedist;
  }

  public double Efficiency(ArrayList<Integer> start, ArrayList<Integer> end, int totalN) {
    double effidist = 0;

    for (int source = 0; source < totalN; source++) {
      Dijkstra diTool = new Dijkstra();
      diTool.makeGraph(false, start, end, totalN);

      diTool.computePaths(source);
      ArrayList<Vertex> vertices = diTool.getVertices();

      for (int destination = 0; destination < totalN; destination++) {
        if (source != destination) {
          double mindist = vertices.get(destination).getMinDistance();

          effidist += 1 / mindist; // Sumation of efficiency
        }
      }
    }

    double efficiency = effidist / (totalN * (totalN - 1));

    return efficiency;
  }

  public double Distance(ArrayList<Integer> start, ArrayList<Integer> end, int totalN) {
    double dist = 0;
    // Dijkstra diTool = new Dijkstra();
    // diTool.makeGraph(false, start, end, totalN);
    for (int source = 0; source < totalN; source++) {

      Dijkstra diTool = new Dijkstra();
      diTool.makeGraph(false, start, end, totalN);

      diTool.computePaths(source);
      for (int destination = 0; destination < totalN; destination++) {
        if (source != destination) {
          double mindist = diTool.getVertices().get(destination).getMinDistance();
          if (dist < mindist) {
            dist = mindist;
          }
        }
      }
    }
    return dist;
  }

  public double[] calBetweenness(ArrayList<Integer> start, ArrayList<Integer> end, int totalN) throws IOException {
    double[] betValue = new double[totalN];
    for (int i = 0; i < totalN; i++) {
      betValue[i] = 0;
    }

    for (int source = 0; source < totalN; source++) {
      Dijkstra betCen = new Dijkstra();
      betCen.makeGraph(false, start, end, totalN);
      betCen.computePaths(source);

      // get shortest path form Dijkstra: destination[pathNum[nodeNum]]
      ArrayList<ArrayList<ArrayList<Integer>>> u0path = betCen.calcU0Paths();

      for (int destination = source + 1; destination < totalN; destination++) {
        ArrayList<Integer> restPathNodes = new ArrayList<>();
        ArrayList<Integer> passThroughNode = new ArrayList<>();
        ArrayList<Integer> passThroughTime = new ArrayList<>();

        int totalPathNum = u0path.get(destination).size();
        for (int pathNum = 0; pathNum < totalPathNum; pathNum++) {
          // show all shortest path list
          // System.out.println(u0path.get(destination).get(pathNum));

          int totalPathNodes = u0path.get(destination).get(pathNum).size();
          // remove sorce node and destination node, add the rest node into arraylist
          for (int nodeNum = 1; nodeNum < totalPathNodes - 1; nodeNum++) {
            int nodes = u0path.get(destination).get(pathNum).get(nodeNum);
            restPathNodes.add(nodes);
          }
        }

        for (int i = 0; i < totalN; i++) {
          int countTime = 0;
          boolean activeNode = false;
          for (int j = 0; j < restPathNodes.size(); j++) {
            if (Objects.equals(i, restPathNodes.get(j))) {
              countTime++;
              activeNode = true;
            }
          }
          if (activeNode == true) {
            passThroughNode.add(i);
            passThroughTime.add(countTime);
          }
        }

        if (!passThroughNode.isEmpty()) {
          for (int i = 0; i < passThroughNode.size(); i++) {
            // outhtml.append("<p>Pass through: node = " + passThroughNode.get(i)
            // + ", times = " + passThroughTime.get(i) + "</p>");
            double coutBetweenness = (double) passThroughTime.get(i) / (double) totalPathNum;
            // outhtml.append("<p>Count Betweenness Centrality = "
            // + coutBetweenness + "</p>");

            betValue[passThroughNode.get(i)] += coutBetweenness;
          }
        }
      }
    }
    return betValue;
  }

  public double[] calDegree(ArrayList<Integer> source, int totalN) {
    double[] nodesDegree = new double[totalN];

    for (int node = 0; node < totalN; node++) {
      double degree = 0;

      for (int i = 0; i < source.size(); i++) {
        if (Objects.equals(node, source.get(i))) {
          degree += 1;
        }
      }

      nodesDegree[node] = degree;
    }

    return nodesDegree;
  }

  private JSONObject prepareNodes(int totalN) {
    JSONObject graphJson = new JSONObject();
    JSONArray jarN = new JSONArray();
    for (int i = 0; i < totalN; ++i) {
      JSONObject node = new JSONObject();
      node.put("id", "B" + i);
      node.put("group", 0);
      jarN.put(node);
    }
    graphJson.put("nodes", jarN);
    return graphJson;
  }

  public String vulnerability(ArrayList<Integer> src, ArrayList<Integer> dst, Integer totalN, String results,
                              String metrics) throws IOException {

    JSONObject graphJson = prepareNodes(totalN);

    results += "<p>=== Vulnerability ===</p>";

    double originEfficiency = Efficiency(src, dst, totalN);
    results += "<p>Efficiency: " + originEfficiency + "</p>";

    double[] reSrc = new double[src.size()];
    double[] reDst = new double[src.size()];
    double[] reAverageDist = new double[src.size()];
    double[] reEfficiency = new double[src.size()];
    double[] reEfficiencyVar = new double[src.size()];

    for (int i = 0; i < src.size(); i++) {
      reSrc[i] = src.get(i);
      reDst[i] = dst.get(i);
    }

    // remove link i, src[i] to dst[i]
    for (int i = 0; i < src.size(); i++) {
      // Target reLink = new Target();
      ArrayList<Integer> relinkSrc = new ArrayList<>();
      ArrayList<Integer> relinkDst = new ArrayList<>();

      int k = 0;
      boolean isMutual = false;
      // find mirror path of removing path
      for (int j = 0; j < src.size(); j++) {
        if (Objects.equals(src.get(j), dst.get(i))
                && Objects.equals(dst.get(j), src.get(i))) {
          k = j;
        }
      }
      if (isMutual == true) {
        // add new path table to neLink arraylist
        for (int m = 0; m < src.size(); m++) {
          if (m != i && m != k) {
            relinkSrc.add(src.get(m));
            relinkDst.add(dst.get(m));
          }
        }
      } else {
        for (int m = 0; m < src.size(); m++) {
          if (m != i) {
            relinkSrc.add(src.get(m));
            relinkDst.add(dst.get(m));
          }
        }
      }

      double avgDist = AverageDist(relinkSrc, relinkDst, totalN);

      reAverageDist[i] = avgDist;

      double efficiency = Efficiency(relinkSrc, relinkDst, totalN);
      reEfficiency[i] = efficiency;

      double vulnerability = (originEfficiency - reEfficiency[i]) / originEfficiency;
      reEfficiencyVar[i] = vulnerability;
    }

    // Sorting
    PowerGridSort powerGridSort = new PowerGridSort();
    powerGridSort.ArrayModel(5, src.size());
    powerGridSort.AddArray(reSrc);
    powerGridSort.AddArray(reDst);
    powerGridSort.AddArray(reAverageDist);
    powerGridSort.AddArray(reEfficiency);
    powerGridSort.AddArray(reEfficiencyVar);
    double[][] sortOutput = new double[5][src.size()];
    sortOutput = powerGridSort.StartSorting(3, 0);
    JSONArray jarN = new JSONArray();
    for (int i = 0; i < src.size(); i++) {
      results += "<p>## Remove Link: " + (int) sortOutput[0][i] + " to "
              + (int) sortOutput[1][i] + " ##</p>";
      results += "<p>Average distance: " + sortOutput[2][i] + "</p>";
      results += "<p>Removed Efficiency: " + sortOutput[3][i] + "</p>";
      results += "<p>Vulnerability: " + sortOutput[4][i] + "</p>";
      // json part
      JSONObject link = new JSONObject();
      link.put("source", "B" + (int) sortOutput[0][i]);
      link.put("target", "B" + (int) sortOutput[1][i]);
//      link.put("average", sortOutput[2][i]);
      link.put("efficiency", sortOutput[3][i]);
      link.put("vulnerability", sortOutput[4][i]);
      jarN.put(link);
    }
    graphJson.put("links", jarN);


    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public String degreeCentrality(ArrayList<Integer> src, Integer totalN, String results, String metrics) throws IOException {
    JSONObject graphJson = prepareNodes(totalN);

    results += "<p>===Degree Centrality===</p>";

    double[] nodesDegreeCentrality = new double[totalN];
    double[] nodesDegree = new double[totalN];
    double[] nodes = new double[totalN];
    for (int i = 0; i < totalN; i++) {
      double degree = 0;

      for (int j = 0; j < src.size(); j++) {
        if (Objects.equals(i, src.get(j))) {
          degree += 1;
        }
      }
      nodesDegree[i] = degree;

      double value = (double) degree / (totalN - 1);
      nodesDegreeCentrality[i] = value;

      nodes[i] = (double) i;
    }

    PowerGridSort powerGridSort = new PowerGridSort();
    powerGridSort.ArrayModel(3, totalN);
    powerGridSort.AddArray(nodes);
    powerGridSort.AddArray(nodesDegree);
    powerGridSort.AddArray(nodesDegreeCentrality);
    double[][] sortOutput = new double[3][totalN];
    sortOutput = powerGridSort.StartSorting(1, 1);
    for (int i = 0; i < totalN; i++) {
      results += "<p>Node [" + (int) sortOutput[0][i]
              + "]: Degree = " + (int) sortOutput[1][i]
              + ", Degree Centrality = " + sortOutput[2][i] + "</p>";
    }

    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public String betweennessCentrality(ArrayList<Integer> src, ArrayList<Integer> dst, Integer totalN, String results,
                                      String metrics)
          throws IOException {

    JSONObject graphJson = prepareNodes(totalN);

    results += "<p>== Betweenness Centrality ==</p>";

    double[] betNodes = new double[totalN];
    double[] betValue = new double[totalN];

    for (int i = 0; i < totalN; i++) {
      betNodes[i] = i;
    }

    betValue = calBetweenness(src, dst, totalN);

    PowerGridSort powerGridSort = new PowerGridSort();
    powerGridSort.ArrayModel(2, totalN);
    powerGridSort.AddArray(betNodes);
    powerGridSort.AddArray(betValue);
    double[][] betSortResults = new double[2][totalN];
    betSortResults = powerGridSort.StartSorting(1, 1);
    for (int i = 0; i < totalN; i++) {
      results += "<p> Node " + (int) betSortResults[0][i] + ": Betweenness Centrality = "
              + betSortResults[1][i] + "</p>";
    }

    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public String cascadingFailure(ArrayList<Integer> src, ArrayList<Integer> dst, Integer totalN, Float alpha,
                                 Float beta, String results, String metrics) throws IOException {
    JSONObject graphJson = prepareNodes(totalN);

    results += "<p>== Cascading Failure  ==</p>"
            + "<p>Alpha = " + alpha + ", Beta = " + beta + "</p>";

    ArrayList<Integer> brokenNodes = new ArrayList<>();
    // S parameters means avalanche size.
    ArrayList<Integer> sPara = new ArrayList<>();
    //
    HashMap<Integer, ArrayList<Integer>> brokenNodesMap = new HashMap<>();

    for (int removeNode = 0; removeNode < totalN; removeNode++) {
      brokenNodes = calCascadingFailue(src, dst, totalN, removeNode, alpha, beta);
      brokenNodesMap.put(removeNode, brokenNodes);
      sPara.add(brokenNodes.size() - 1);
    }

    double sumSPara, avalancheSize;
    sumSPara = 0;
    for (int i = 0; i < sPara.size(); i++) {
      sumSPara += sPara.get(i);
    }
    avalancheSize = sumSPara / totalN / (totalN - 1);

    results += "<p> Avalanche Size: " + avalancheSize + "</p>";

    /* Sorting */
    double[] nodes, sParameter;
    nodes = new double[totalN];
    sParameter = new double[totalN];
    for (int i = 0; i < totalN; i++) {
      nodes[i] = i;
      sParameter[i] = sPara.get(i);
    }

    PowerGridSort powerGridSort = new PowerGridSort();
    powerGridSort.ArrayModel(2, totalN);
    powerGridSort.AddArray(nodes);
    powerGridSort.AddArray(sParameter);

    double[][] sortResults = new double[2][totalN];
    sortResults = powerGridSort.StartSorting(1, 1);
    results += "<p>#S parameters of all nodes:</p>";
    for (int i = 0; i < sPara.size(); i++) {
      results += "<p>Node " + (int) sortResults[0][i] + ": " + "S[" + (int) sortResults[0][i] + "] = "
              + sortResults[1][i] + ", Broken Nodes: " + brokenNodesMap.get((int) sortResults[0][i]) + "</p>";
    }

    results += "<p>Cascading Failure Process End</p>";

    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public ArrayList<Integer> calCascadingFailue(ArrayList<Integer> start, ArrayList<Integer> end, Integer totalN,
                                               Integer removeNode, Float alpha, Float beta) throws IOException {

    double[] nodesDegree = new double[totalN];
    int[][] d1MapArray = new int[totalN][totalN];
    double[] load = new double[totalN];
    double[] capacity = new double[totalN];

    // Create degree of nodes array.
    nodesDegree = calDegree(start, totalN);
    // System.out.println("check point 1: Degree of nodes");
    // for (int i = 0; i < totalN; i++) {
    // System.out.println("Node [" + i + "]: Degree = " + (int) nodesDegree[i]);
    // }
    // System.out.println("check point 1: Degree of nodes");
    // for (int i = 0; i < totalN; i++) {
    // System.out.println("Node [" + i + "]: Degree = " + (int) nodesDegree[i]);
    // }

    // Create distance equal to one data array of input topology.
    d1MapArray = calD1Map(start, end, totalN);
    // System.out.println("check point 2: D1 Map");
    // String dataStringOut = "array output\n";
    // for (int[] row : d1MapArray) {
    // for (int element : row) {
    // dataStringOut += String.valueOf(element) + " ";
    // }
    // dataStringOut += "\n";
    // }
    // System.out.println(dataStringOut);

    // Create load array, which record load of nodes information at each time.
    for (int i = 0; i < totalN; i++) {
      load[i] = Math.pow(nodesDegree[i], beta);
    }
    // System.out.println("check point 3: Load of nodes");
    // System.out.println("beta value = " + beta);
    // //clear value of string out
    // dataStringOut = "";
    // for (double element : load) {
    // dataStringOut += String.valueOf(element) + " ";
    // }
    // System.out.println(dataStringOut);

    // Create capacity of nodes.
    for (int i = 0; i < totalN; i++) {
      capacity[i] = (1 + alpha) * load[i];
    }
    // System.out.println("Capacity of nodes");
    // System.out.println("alpha value = " + alpha);
    // //clear value of string type output
    // dataStringOut = "";
    // for (double element : capacity) {
    // dataStringOut += String.valueOf(element) + " ";
    // }
    // System.out.println(dataStringOut);

    // Remove Node.
    // System.out.println("check point 4: Remove node: " + removeNode);
    double sumNeighborLoad = 0;
    ArrayList<Integer> avalancheNodesList = new ArrayList<>();
    ArrayList<Integer> brokenList = new ArrayList<>();
    ArrayList<Integer> neighborNodes = new ArrayList<>();

    for (int i = 0; i < totalN; i++) {
      if (d1MapArray[removeNode][i] == 1) {
        neighborNodes.add(i);
      }
    }

    // System.out.println("check point 5: Neighbor Nodes of Remove Node " +
    // removeNode);
    // System.out.println(neighborNodes);

    for (int i = 0; i < neighborNodes.size(); i++) {
      sumNeighborLoad += load[neighborNodes.get(i)];
    }
    // System.out.println(sumNeighborLoad);

    // Redistribute load
    for (int i = 0; i < neighborNodes.size(); i++) {
      load[neighborNodes.get(i)] += load[removeNode] * load[neighborNodes.get(i)] / sumNeighborLoad;
    }
    // add removeNode into broken nodes array list.
    avalancheNodesList.add(removeNode);
    // set load of node 0 as zero.
    load[removeNode] = 0;
    // System.out.println("check point 6: Avalanche nodes list.");
    // System.out.println(avalancheNodesList);
    // System.out.println("Redistribute load.");
    // //clear value of string out
    // dataStringOut = "";
    // for (double element : load) {
    // dataStringOut += String.valueOf(element) + " ";
    // }
    // System.out.println(dataStringOut);

    // Find broken nodes.
    for (int i = 0; i < neighborNodes.size(); i++) {
      if (load[neighborNodes.get(i)] > capacity[neighborNodes.get(i)]) {
        brokenList.add(neighborNodes.get(i));
        avalancheNodesList.add(neighborNodes.get(i));
      }
    }
    // System.out.println("@@Remone Node[" + removeNode + "]:");
    // System.out.println("check point 7: Broken nodes list.");
    // System.out.println(brokenList);
    // System.out.println("Avalanche nodes list.");
    // System.out.println(avalancheNodesList);

    // Avalanche occure

    while (!brokenList.isEmpty()) {
      for (int i = 0; i < brokenList.size(); i++) {
        neighborNodes.clear();
        for (int j = 0; j < totalN; j++) {
          if (d1MapArray[brokenList.get(i)][j] == 1) {
            neighborNodes.add(j);
          }
        }
        // *bug fixd.
        ArrayList<Integer> takeOffNodes = new ArrayList<>();
        for (int k = 0; k < neighborNodes.size(); k++) {
          for (int l = 0; l < avalancheNodesList.size(); l++) {
            if (Objects.equals(neighborNodes.get(k), avalancheNodesList.get(l))) {
              takeOffNodes.add(neighborNodes.get(k));
            }
          }
        }

        for (int q = 0; q < takeOffNodes.size(); q++) {
          neighborNodes.remove(takeOffNodes.get(q));
        }

        // System.out.println("The neighbor of node " + brokenList.get(i) + ": ");
        // System.out.println(neighborNodes);
        sumNeighborLoad = 0;

        for (int m = 0; m < neighborNodes.size(); m++) {
          sumNeighborLoad += load[neighborNodes.get(m)];
        }

        for (int n = 0; n < neighborNodes.size(); n++) {
          load[neighborNodes.get(n)] += load[brokenList.get(i)] * load[neighborNodes.get(n)] / sumNeighborLoad;
        }

        load[brokenList.get(i)] = 0;
        // dataStringOut = "";
        // for (double element : load) {
        // dataStringOut += String.valueOf(element) + " ";
        // }
        // System.out.println("Load: " + dataStringOut);
      }

      brokenList.clear();
      for (int i = 0; i < totalN; i++) {
        if (load[i] > capacity[i]) {
          brokenList.add(i);
          avalancheNodesList.add(i);
        }
      }
      // System.out.println("Avalanche nodes list: " + avalancheNodesList);
      // System.out.println("Broken nodes list: " + brokenList);
    }
    Collections.sort(avalancheNodesList);
    // System.out.println("##Final avalanche nodes list: " + avalancheNodesList);

    return avalancheNodesList;
  }

  public int[][] calD1Map(ArrayList<Integer> startNode, ArrayList<Integer> endNode, int totalN)
          throws IOException {
    int[][] d1MapArray = new int[totalN][totalN];

    // Get connection information of topology from Dijkstra
    for (int source = 0; source < totalN; source++) {
      Dijkstra topoInfo = new Dijkstra();
      topoInfo.makeGraph(false, startNode, endNode, totalN);
      topoInfo.computePaths(source);

      // get shortest path form Dijkstra: destination[pathNum[nodeNum]]
      ArrayList<ArrayList<ArrayList<Integer>>> u0path = topoInfo.calcU0Paths();
      for (int destination = 0; destination < totalN; destination++) {
        int totalPathNum = u0path.get(destination).size();
        for (int pathNum = 0; pathNum < totalPathNum; pathNum++) {
          int totalNodesNum = u0path.get(destination).get(pathNum).size();
          if (totalNodesNum == 2) {
            // checkpoint
            d1MapArray[source][destination] = 1;
          }
        }
      }

    }
    return d1MapArray;
  }

  public void writeOutput(String results, Boolean doWrite, String metrics, JSONObject graphData) throws IOException {
    if (doWrite) {
      LocalDateTime now = LocalDateTime.now();
      DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
      String fileName = "output/" + metrics + "_" + now.format(formatter) + ".html";

      try {
        File myFile = new File(fileName);
        myFile.getParentFile().mkdirs();
        myFile.createNewFile();
        FileWriter myWriter = new FileWriter(myFile);
        myWriter.write(results);
        myWriter.close();
        System.out.println("Write to " + fileName);
      } catch (IOException e) {
        e.printStackTrace();
      }

      if (graphData != null) {
        String d3jsFileName = "output/forceDirected_" + metrics + "_" + now.format(formatter) + ".html";
        standalonePageWriter.writer(d3jsFileName, metrics, graphData);
      }
    }
  }

  public String basic(ArrayList<Integer> src, ArrayList<Integer> dst, Integer totalN, String results, String metrics) throws IOException {
    JSONObject graphJson = prepareNodes(totalN);

    double distance = Distance(src, dst, totalN);
    double avgDistance = AverageDist(src, dst, totalN);

    results += "<p> Distance: " + distance + "</p>"
            + "<p> Average distance: " + avgDistance + "</p>";

    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public String infinitePoints(ArrayList<Integer> src, ArrayList<Integer> dst, int totalN, String results,
                               String metrics) throws IOException {
    JSONObject graphJson = prepareNodes(totalN);

    List<Integer> infinitePointsResult = new ArrayList<>();
    HashMap<Integer, Double> nodeDistPair = new HashMap<>();

    for (int source = 0; source < totalN; source++) {
      Dijkstra diTool = new Dijkstra();
      diTool.makeGraph(false, src, dst, totalN);
      double dist = 0;

      diTool.computePaths(source);

      for (int destination = 0; destination < totalN; destination++) {
        if (source != destination) {
          double mindist = diTool.getVertices().get(destination).getMinDistance();

          // System.out.println(source + ", " + destination + ", " + mindist);
          if (dist < mindist) {
            dist = mindist;
          }
        }
      }

      nodeDistPair.put(source, dist);

      if (Double.valueOf(dist).isInfinite()) {
        infinitePointsResult.add(source);
      }
    }

    results += "<p> Infinite Points Length: " + infinitePointsResult.size() + "</p>"
            + "<p> Infinite Points: " + infinitePointsResult + "</p>"
            + "<p> Node Distance Pair: " + nodeDistPair + "</p>";
    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public String multipleCascadingFailure(ArrayList<Integer> src, ArrayList<Integer> dst, Integer totalN,
                                         ArrayList<Float> alphaArr, Float betaArr, String results, String metrics) throws IOException {
    JSONObject graphJson = prepareNodes(totalN);

    results += "<p>== Multiple Cases Cascading Failure  ==</p>";
    Float beta = betaArr;

    for (Float alpha : alphaArr) {
      results += "<p>Alpha = " + alpha + ", Beta = " + beta + "</p>";

      ArrayList<Integer> brokenNodes = new ArrayList<>();
      // S parameters means avalanche size.
      ArrayList<Integer> sPara = new ArrayList<>();

      for (int removeNode = 0; removeNode < totalN; removeNode++) {
        brokenNodes = calCascadingFailue(src, dst, totalN, removeNode, alpha, beta);
        sPara.add(brokenNodes.size() - 1);
      }

      double sumSPara, avalancheSize;
      sumSPara = 0;
      for (int i = 0; i < sPara.size(); i++) {
        sumSPara += sPara.get(i);
      }
      avalancheSize = sumSPara / totalN / (totalN - 1);

      results += "<p> Avalanche Size: " + avalancheSize + "</p>";
    }

    writeOutput(results, true, metrics, graphJson);
    return results;
  }

  public String vulnerabilityLength(ArrayList<Integer> src, ArrayList<Integer> dst, ArrayList<Float> lengthArr,
                                    Integer totalN, String results, String metrics) throws IOException {

    JSONObject graphJson = prepareNodes(totalN);

    results += "<p>=== Vulnerability Length Weighted ===</p>";
    Double originEfficiency = efficiencyLength(src, dst, lengthArr, totalN);

    results += "<p>Efficiency: " + originEfficiency + "</p>";

    double[] reSrc = new double[src.size()];
    double[] reDst = new double[src.size()];
    double[] reEfficiency = new double[src.size()];
    double[] reEfficiencyVar = new double[src.size()];

    for (int i = 0; i < src.size(); i++) {
      reSrc[i] = src.get(i);
      reDst[i] = dst.get(i);
    }

    // remove link i, src[i] to dst[i]
    for (int i = 0; i < src.size(); i++) {
      // Target reLink = new Target();
      ArrayList<Integer> relinkSrc = new ArrayList<>();
      ArrayList<Integer> relinkDst = new ArrayList<>();
      ArrayList<Float> reLengthArr = new ArrayList<>();

      int k = 0;
      boolean isMutual = false;
      // find mirror path of removing path
      for (int j = 0; j < src.size(); j++) {
        if (Objects.equals(src.get(j), dst.get(i))
                && Objects.equals(dst.get(j), src.get(i))) {
          k = j;
          isMutual = true;
        }
      }
      if (isMutual == true) {
        // add new path table to neLink arraylist
        for (int m = 0; m < src.size(); m++) {
          if (m != i && m != k) {
            relinkSrc.add(src.get(m));
            relinkDst.add(dst.get(m));
            reLengthArr.add(lengthArr.get(m));
          }
        }
      } else {
        for (int m = 0; m < src.size(); m++) {
          if (m != i) {
            relinkSrc.add(src.get(m));
            relinkDst.add(dst.get(m));
            reLengthArr.add(lengthArr.get(m));
          }
        }
      }



      double efficiency = efficiencyLength(relinkSrc, relinkDst, reLengthArr, totalN);
      reEfficiency[i] = efficiency;

      double vulnerability = (originEfficiency - reEfficiency[i]) / originEfficiency;
      reEfficiencyVar[i] = vulnerability;
    }

    // Sorting
    PowerGridSort powerGridSort = new PowerGridSort();
    powerGridSort.ArrayModel(4, src.size());
    powerGridSort.AddArray(reSrc);
    powerGridSort.AddArray(reDst);
    powerGridSort.AddArray(reEfficiency);
    powerGridSort.AddArray(reEfficiencyVar);

    double[][] sortOutput = new double[4][src.size()];
    sortOutput = powerGridSort.StartSorting(2, 0);

    for (int i = 0; i < src.size(); i++) {
      results += "<p>## Remove Link: " + (int) sortOutput[0][i] + " to "
              + (int) sortOutput[1][i] + " ##</p>";
      results += "<p>Removed Efficiency: " + sortOutput[2][i] + "</p>";
      results += "<p>Vulnerability: " + sortOutput[3][i] + "</p>";
    }

    writeOutput(results, true, metrics, graphJson);

    return results;
  }

  public Double efficiencyLength(ArrayList<Integer> src, ArrayList<Integer> dst, ArrayList<Float> lengthArr,
                                 Integer totalN) {

    Double effidist = 0.0;

    for (int source = 0; source < totalN; source++) {
      Dijkstra diTool = new Dijkstra();
      diTool.makeGraphWithDistance(false, src, dst, lengthArr, totalN);
      diTool.computePaths(source);
      ArrayList<Vertex> vertices = diTool.getVertices();

      for (int destination = 0; destination < totalN; destination++) {
        if (source != destination) {
          double mindist = vertices.get(destination).getMinDistance();

          effidist += 1 / mindist; // Sumation of efficiency
        }
      }
    }

    Double efficiency = effidist / (totalN * (totalN - 1));

    return efficiency;
  }
}
